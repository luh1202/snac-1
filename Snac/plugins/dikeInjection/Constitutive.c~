/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
**
** Copyright (C), 2003,
**	Steve Quenette, 110 Victoria Street, Melbourne, Victoria, 3053, Australia.
**	Californian Institute of Technology, 1200 East California Boulevard, Pasadena, California, 91125, USA.
**	University of Texas, 1 University Station, Austin, Texas, 78712, USA.
**
** Authors:
**	Stevan M. Quenette, Senior Software Engineer, VPAC. (steve@vpac.org)
**	Stevan M. Quenette, Visitor in Geophysics, Caltech.
**	Luc Lavier, Research Scientist, The University of Texas. (luc@utig.ug.utexas.edu)
**	Luc Lavier, Research Scientist, Caltech.
**
** This program is free software; you can redistribute it and/or modify it
** under the terms of the GNU General Public License as published by the
** Free Software Foundation; either version 2, or (at your option) any
** later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
**
** $Id: Constitutive.c 3274 2007-03-27 20:25:29Z EunseoChoi $
**
**~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#include <mpi.h>
#include <StGermain/StGermain.h>
#include <StGermain/FD/FD.h>
#include "Snac/Snac.h"
#include "Snac/ViscoPlastic/ViscoPlastic.h"
#include "types.h"
#include "Context.h"
#include "Constitutive.h"
#include "Register.h"
#include <math.h>
#include <string.h>
#include <assert.h>
#include "Track.h"
#include <stdio.h>

#define SkipStep 100
#ifndef PI
#ifndef M_PIl
#ifndef M_PI
#define PI 3.14159265358979323846
#else
#define PI M_PI
#endif
#else
#define PI M_PIl
#endif
#endif
//#define DEBUG

//int maxxK = 9;  //meshSizeK - 2 ; for M-factor vary from 0 to 1

void SnacDikeInjection_Constitutive( void* _context, Element_LocalIndex element_lI ) {
        Snac_Context* self = (Snac_Context*)_context;
      
	Snac_Context*		        context = (Snac_Context*)_context;
	SnacDikeInjection_Context*	contextExt = ExtensionManager_Get(
					       		context->extensionMgr,
	      						context,
							SnacDikeInjection_ContextHandle );
	Snac_Element			*element = Snac_Element_At( context, element_lI );
	SnacViscoPlastic_Element* viscoplasticElement = ExtensionManager_Get( context->mesh->elementExtensionMgr, element, SnacViscoPlastic_ElementHandle );
	const Snac_Material		*material = &context->materialProperty[element->material_I];
	
	/* make local copies. */
    long long counter = 0;
	double startX = contextExt->startX;
	double endX = contextExt->endX;
	double startZ = contextExt->startZ;
	double endZ = contextExt->endZ;
	double dX = endX-startX;
	double dZ = endZ-startZ;
	double Mb = contextExt->Mb;
        double Me = contextExt->Me; 
        double M_type = contextExt->M_type;
	//double maxK = contextExt->maxK; //new added;   why this not working        
	//	fprintf (stderr, "maxK1 = %f\n", maxK);
        double elem_dX = 0.0;
	double epsilon_xx = 0.0;
	Tetrahedra_Index tetra_I;//build/include/Snac/types.h:typedef unsigned intTetrahedra_Index;

	/* Some convenience stuffs. */
        //MeshLayout*			meshLayout = (MeshLayout*)context->meshLayout;
	//HexaMD*				decomp = (HexaMD*)meshLayout->decomp;
	IJK				ijk;
	

	//	const Index                     kCount = decomp->nodeGlobal3DCounts[2];
	Mesh*                           mesh = context->mesh;
        MeshLayout*                     layout = (MeshLayout*)mesh->layout;
        HexaMD*                         decomp = (HexaMD*)layout->decomp;

	Element_GlobalIndex             global_K_range = decomp->elementGlobal3DCounts[2];
	
        Element_GlobalIndex		element_gI = _MeshDecomp_Element_LocalToGlobal1D( decomp, element_lI );
        RegularMeshUtils_Element_1DTo3D( decomp, element_gI, &ijk[0], &ijk[1], &ijk[2] );

        //iiiii = N;   why this doesn't work??????????
	//why this doesn't work? 12345678910 012345678910 instead of 1 to n        int iiiii = 0;   //added later for M-factor variation
       
	/* for ( int iii = 0; iii<7; iii++) {
	fprintf(stderr," (Snac_Element_NodeCoord( context, element_lI, %d))[0] = %e\n", iii,  Snac_Element_NodeCoord( context, element_lI, iii)[0]); 
	}*/
	//epsilon_xx = (contextExt->injectionRate*context->dt)/elem_dX;

	//fprintf(stderr,"context->dt=%e epsilon_xx=%e\n, injectionRate=%e",context->dt,epsilon_xx, contextExt->injectionRate);
	//	epsilon_xx = (contextExt->injectionRate*context->dt)/elem_dX; 
    //fprintf(stderr, "--------debug-----------\n");
    //fprintf(stderr, "\nSnacDikeInjection_Constitutive() is called!\n");
    //fprintf(stderr, "self->currentTime = %g\n\n", self->currentTime);
    
	for( tetra_I = 0; tetra_I < Tetrahedra_Count; tetra_I++ ) {
		Coord baryCenter;
		double distance = 0.0;
		double numer = 0.0;
		double denom = 1.0;
		Node_LocalIndex node_lI;
		unsigned int dim;

	
	

		//                             iiiii = &kk;  	


		//fprintf(stderr, "Tetrahedra_Count=%d,  tetra_I=%d\n",Tetrahedra_Count,tetra_I);

		/*
		  First decide whther this tet is a part of the dike.
		*/

		/* compute barycenter. */
		for( dim=0; dim < 3; dim++ ){
		   baryCenter[dim] = 0.0;
		}

               for(node_lI=0; node_lI<4; node_lI++) {
	     Coord* tetNodeCoord = Snac_Element_NodeCoord( context, element_lI, TetraToNode[tetra_I][node_lI] );
	     //fprintf(stderr, "tetra_I=%d\n", tetra_I);
	     //fprintf(stderr, "node_lI=%d\n", node_lI);
	     //fprintf(stderr, "tetNodeCoord[%d][%d]=%e\n", tetra_I, node_lI, Snac_Element_NodeCoord( context, element_lI, TetraToNode[tetra_I][node_lI]));
	         for( dim=0; dim < 3; dim++ ){
                   baryCenter[dim] += 0.25 * (*tetNodeCoord)[dim];
	           //fprintf(stderr, "(*tetNodeCoord)[%d]=%e\n", dim, (*tetNodeCoord)[dim]);
	         }
               }
	     //fprintf(stderr,"baryCenter[0]=%e\n,baryCenter[1]=%e\n,baryCenter[2]=%e\n",baryCenter[0],baryCenter[1],baryCenter[2]);
        	
/* The following is the general formula for distance from a li（）(diagonal of dx dz)o a point. */

/*		numer = fabs( dX*(startZ-baryCenter[2])-(startX-baryCenter[0])*dZ );
		denom = sqrt( dX*dX + dZ*dZ );
		assert( denom > 0.0 );
		distance = numer/denom;
*/	
	//fprintf(stderr, "distance = %e\n", distance);	
          	//	fprintf(stderr,"distance=%e, dikeDepth=%e",distance,contextExt->dikeDepth);
	       
/*the above way for restricting dike in x-axis can be replaced by simple method below*/		
	       distance = fabs( baryCenter[0] - 0.5 * (startX + endX) );

                 /* 
		   If part of the dike, adjust stresses. 

		   Note that although parameters can define a ridge with an arbitrary orientation,
		   the following stress mods assume ridges are parallel with z-axis.
		   One can implement tensor rotation when necessary.
		 */
	      

	       if( (distance < 0.5*contextExt->dikeWidth) && (baryCenter[1] >= -contextExt->dikeDepth) && (-contextExt->dikeTop >= baryCenter[1]) ){

	elem_dX = 0.25*( 
      	(Snac_Element_NodeCoord( context, element_lI, 1)[0]-Snac_Element_NodeCoord( context, element_lI, 0)[0]) + 
	(Snac_Element_NodeCoord( context, element_lI, 2)[0]-Snac_Element_NodeCoord( context, element_lI, 3)[0]) + 
	(Snac_Element_NodeCoord( context, element_lI, 5)[0]-Snac_Element_NodeCoord( context, element_lI, 4)[0]) + 
        (Snac_Element_NodeCoord( context, element_lI, 6)[0]-Snac_Element_NodeCoord( context, element_lI, 7)[0]) 
	 );
	
	//fprintf(stderr,"elem_dX=%e \n",elem_dX);

	epsilon_xx = (contextExt->injectionRate*context->dt)/elem_dX/2; 

	//fprintf(stderr,"epsilon_xx=%e \n",epsilon_xx);
	         StressTensor*		stress = &element->tetra[tetra_I].stress;
			//fprintf(stderr, "baryCenter[1]=%e\n", baryCenter[1]);
            		//fprintf(stderr, "distance = %e\n", distance);
                        //fprintf(stderr, "element_lI=%d\n", element_lI);				
// fprintf(stderr,"el=%d (%d %d %d) tet=%d (%e %e %e) distance=%e startX=%e width=%e\n",	element_lI,ijk[0],ijk[1],ijk[2],tetra_I,baryCenter[0], baryCenter[1], baryCenter[2],distance,startX,contextExt->dikeWidth);
		 //fprintf(stderr, "origin(*stress)[0][0]=%e\n", (*stress)[0][0]);
/*P197 Geodynamics*/
		 //fprintf(stderr, "ijk[2]=%d\n", ijk[2]);                 
                 int TT = ijk[2];
		 // fprintf(stderr, "maxK = %f\n", maxK);
	      

		 /*  why this way , maxx K will be hardwire to 0???????????????????????????????????????????????
              (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * ijk[2] / maxxK;
              (*stress)[1][1] -= material->lambda * epsilon_xx * ijk[2] / maxxK;
              (*stress)[2][2] -= material->lambda * epsilon_xx * ijk[2] / maxxK;
		 */
		 /*
                  Ways of implementing M along axis:
		  1) linear
		  2) sinusoidal
		  3) sqrt
		  4) one third
		  */
		 //global_K_range is the total elements in z axis
		 //ijk[2] vary from 0 to global_K_range - 1

		 //the if global_K_range==1 is for 1d pseudo test
		 if (0){  // if (global_K_range==1){
		   (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx;
		   (*stress)[1][1] -= material->lambda * epsilon_xx;
		   (*stress)[2][2] -= material->lambda * epsilon_xx;
		 
             printf("global_K_range==1\n");
             
                 }
         else{
             
             counter += 1;
             FILE *fp;
             
		   if( M_type == 1 ){
		   double M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb);
		   /*(*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * ((ijk[2]+1) / ( global_K_range)*(Me-Mb)+Mb);
		   (*stress)[1][1] -= material->lambda * epsilon_xx * ((ijk[2]+1) / ( global_K_range)*(Me-Mb)+Mb);
		   (*stress)[2][2] -= material->lambda * epsilon_xx * ((ijk[2]+1) / ( global_K_range)*(Me-Mb)+Mb);
		   */
		   (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
		   (*stress)[1][1] -= material->lambda * epsilon_xx * M;
		   (*stress)[2][2] -= material->lambda * epsilon_xx * M;
		   //fprintf(stderr, " M_type=%f\n global_K_range=%d\n ijk[2]=%d\n, M = %f\n \n \n",  M_type, global_K_range, ijk[2], M);
           }
		   if( M_type == 2 ){
           double M = ( sin( (ijk[2]+0.0f) / ( global_K_range + 0.0f) * PI / 2) * (Me - Mb) + Mb);
		     (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
		     (*stress)[1][1] -= material->lambda * epsilon_xx * M;
		     (*stress)[2][2] -= material->lambda * epsilon_xx * M;
		     //fprintf(stderr, " M_type=%f\n global_K_range=%d\n ijk[2]=%d\n, M = %f\n \n \n",  M_type, global_K_range, ijk[2], M);
		   }		 
		   if( M_type == 3 ){
           double M =  pow( (ijk[2]+0.0f) / ( global_K_range + 0.0f), 0.5 ) * (Me - Mb) + Mb;
		     (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
		     (*stress)[1][1] -= material->lambda * epsilon_xx * M;
		     (*stress)[2][2] -= material->lambda * epsilon_xx * M;
		     //fprintf(stderr, " M_type=%f\n global_K_range=%d\n ijk[2]=%d\n, M = %f\n \n \n",  M_type, global_K_range, ijk[2], M);
		   }		 
		   if( M_type == 4 ){
           double M =  pow( (ijk[2]+0.0f) / ( global_K_range + 0.0f), 0.333333 ) * (Me - Mb) + Mb;
		     (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
		     (*stress)[1][1] -= material->lambda * epsilon_xx * M;
		     (*stress)[2][2] -= material->lambda * epsilon_xx * M;
		     //fprintf(stderr, " M_type=%f\n global_K_range=%d\n ijk[2]=%d\n, M = %f\n \n \n",  M_type, global_K_range, ijk[2], M);
		   }		 
		     //Hao Lu 2017-7-28 local changing M
             //In input file, Mb and Me must be set as 0.2 to achive the designed function, which M is change within 0.3 to 0.7
             //period 2Ma
            if( M_type == 5 ){
            double M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb)*sin(((2*PI)/(6.3072e+13))*(self->currentTime))+0.5;
             (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
             (*stress)[1][1] -= material->lambda * epsilon_xx * M;
             (*stress)[2][2] -= material->lambda * epsilon_xx * M;
                         //fprintf(stderr, " M_type=%f\n global_K_range=%d\n ijk[2]=%d\n, M = %f\n \n \n",  M_type, global_K_range, ijk[2], M);
                
                // printf("currentTime: %f    M = %f\n", self->currentTime, M);
                // 20000 yrs data frequency
                if ((long)self->currentTime % 630720000000 == 0)
                {
                    fp = fopen("data_2ma_period_type5.txt", "a+");
                    if (fp == NULL)
                    {
                        printf("Cannot open file!\n");
                        exit(0);
                    }
                    fprintf(fp, "%f\t%f\n", self->currentTime, M);
                    if (fclose(fp))
                        printf("File close error!\n");
                }
           }
             //Hao Lu 2017-8-5
             //period 1Ma
             if( M_type == 6 ){
             double M = M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb)*sin(((2*PI)/(3.1536e+13))*(self->currentTime))+0.5;
                 
                 (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
                 (*stress)[1][1] -= material->lambda * epsilon_xx * M;
                 (*stress)[2][2] -= material->lambda * epsilon_xx * M;
                 
                 // printf("currentTime: %f    M = %f\n", self->currentTime, M);
                 //10000 yrs data frequency
                 if ((long)self->currentTime % 315360000000 == 0)
                 {
                     fp = fopen("data_1ma_period_type6.txt", "a+");
                     if (fp == NULL)
                     {
                         printf("Cannot open file!\n");
                         exit(0);
                     }
                     fprintf(fp, "%f\t%f\n", self->currentTime, M);
                     if (fclose(fp))
                         printf("File close error!\n");
                 }
             }
                //period 0.5Ma
             if( M_type == 7 ){
                 double M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb)*sin(((2*PI)/(1.5768e+13))*(self->currentTime))+0.5;
                 
                 (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
                 (*stress)[1][1] -= material->lambda * epsilon_xx * M;
                 (*stress)[2][2] -= material->lambda * epsilon_xx * M;
                 
                 // printf("currentTime: %f    M = %f\n", self->currentTime, M);
                 // 5000 yrs data frequency
                 if ((long)self->currentTime % 157680000000 == 0)
                 {
                     fp = fopen("data_500kyrs_period_type7.txt", "a+");
                     if (fp == NULL)
                     {
                         printf("Cannot open file!\n");
                         exit(0);
                     }
                     fprintf(fp, "%f\t%f\n", self->currentTime, M);
                     if (fclose(fp))
                         printf("File close error!\n");
                 }
             }

                 //period 0.25Ma
             if( M_type == 8 ){
                 double M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb)*sin(((2*PI)/(7.884e+12))*(self->currentTime))+0.5;
                 
                 (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
                 (*stress)[1][1] -= material->lambda * epsilon_xx * M;
                 (*stress)[2][2] -= material->lambda * epsilon_xx * M;
                 
                 // printf("currentTime: %f    M = %f\n", self->currentTime, M);
                 // 2500 yrs data frequency
                 if ((long)self->currentTime % 78840000000 == 0)
                 {
                     fp = fopen("data250kyrs_period_type8.txt", "a+");
                     if (fp == NULL)
                     {
                         printf("Cannot open file!\n");
                         exit(0);
                     }
                     fprintf(fp, "%f\t%f\n", self->currentTime, M);
                     if (fclose(fp))
                         printf("File close error!\n");
                 }
             }

             //period 0.1Ma
             if( M_type == 9 ){
                 double M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb)*sin(((2*PI)/(3.942e+12))*(self->currentTime))+0.5;
                 
                 (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
                 (*stress)[1][1] -= material->lambda * epsilon_xx * M;
                 (*stress)[2][2] -= material->lambda * epsilon_xx * M;
                 
                 // printf("currentTime: %f    M = %f\n", self->currentTime, M);
                 // 1000 yrs data frequency 
                 if ((long)self->currentTime % 31536000000 == 0)
                 {
                     fp = fopen("data_100kyrs_period_type9.txt", "a+");
                     if (fp == NULL)
                     {
                         printf("Cannot open file!\n");
                         exit(0);
                     }
                     fprintf(fp, "%f\t%f\n", self->currentTime, M);
                     if (fclose(fp))
                         printf("File close error!\n");
                 }
           }
            //period 0.05Ma
             if( M_type == 10 ){
                 double M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb)*sin(((2*PI)/(1.971e+12))*(self->currentTime))+0.5;
                 
                 (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
                 (*stress)[1][1] -= material->lambda * epsilon_xx * M;
                 (*stress)[2][2] -= material->lambda * epsilon_xx * M;
                 
                 // printf("currentTime: %f    M = %f\n", self->currentTime, M);
                 // 500 yrs data frequency
                 if ((long)self->currentTime % 15768000000 == 0)
                 {
                     fp = fopen("data_50kyrs_period_type10.txt", "a+");
                     if (fp == NULL)
                     {
                         printf("Cannot open file!\n");
                         exit(0);
                     }
                     fprintf(fp, "%f\t%f\n", self->currentTime, M);
                     if (fclose(fp))
                         printf("File close error!\n");
                 }
             }
             //period 0.01Ma
             if( M_type == 11 ){
                 double M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb)*sin(((2*PI)/(3.942e+11))*(self->currentTime))+0.5;
                 
                 (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
                 (*stress)[1][1] -= material->lambda * epsilon_xx * M;
                 (*stress)[2][2] -= material->lambda * epsilon_xx * M;
                 
                 // printf("currentTime: %f    M = %f\n", self->currentTime, M);
                 // 100 yrs data frequency
                 if ((long)self->currentTime % 3153600000 == 0)
                 {
                     fp = fopen("data_10kyrs_period_type11.txt", "a+");
                     if (fp == NULL)
                     {
                         printf("Cannot open file!\n");
                         exit(0);
                     }
                     fprintf(fp, "%f\t%f\n", self->currentTime, M);
                     if (fclose(fp))
                         printf("File close error!\n");
                 }
             }
             //period 0.005Ma
             if( M_type == 12 ){
                 double M = ((ijk[2]+0.0f) / ( global_K_range + 0.0f) * (Me - Mb) + Mb)*sin(((2*PI)/(1.971e+11))*(self->currentTime))+0.5;
                 
                 (*stress)[0][0] -= (material->lambda + 2.0f * material->mu) * epsilon_xx * M;
                 (*stress)[1][1] -= material->lambda * epsilon_xx * M;
                 (*stress)[2][2] -= material->lambda * epsilon_xx * M;
                 
                 // printf("currentTime: %f    M = %f\n", self->currentTime, M);
                 // 50 yrs data write frequency
                 if ((long)self->currentTime % 1576800000 == 0)
                 {
                     fp = fopen("data_5kyrs_period_type12.txt", "a+");
                     if (fp == NULL)
                     {
                         printf("Cannot open file!\n");
                         exit(0);
                     }
                     fprintf(fp, "%f\t%f\n", self->currentTime, M);
                     if (fclose(fp))
                         printf("File close error!\n");
                 }
             }

             
		 }

		 
			//fprintf(stderr, "dike(*stress)[0][0]=%e\n", (*stress)[0][0]);			
			/* Also assuming viscoplastic rheology is used. */
		 //		       	viscoplasticElement->plasticStrain[tetra_I] = 0.0;
			//just add the above line code can solve the plastic strain too much at dike problem!!
			//However, I took 4hours playing around in viscoplastic_BI
			//try to add everything here at there, which is so hard
			//adding a variable i.e. endZ itsel is already hard, let along finding the diking element and 
			//get zero plasticStrain
			//Point is
			//1)Before doing thing, really think carefully, sometimes life will be much easier
			// when you use a easier method
			//2) Pointer is great, it can let things easier.
			//3)you have to know exactly what is the global variable, what does it contains, which 
			//pointers can you use everywhere and how to use it. 
	     }

             if( (distance < 0.5 * contextExt->dikeWidth) && (baryCenter[1] >= -contextExt->dikeDepth) ){

 	viscoplasticElement->plasticStrain[tetra_I] = 0.0;


	     }
	}
}
